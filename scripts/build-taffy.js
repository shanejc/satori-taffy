import { readFile, writeFile, mkdir } from 'fs/promises'
import { resolve, dirname } from 'path'
import { fileURLToPath } from 'url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const projectRoot = resolve(__dirname, '..')

async function buildTaffyPrebuilt() {
  console.log('üì¶ Building pre-built Taffy WASM...')
  
  try {
    // Read the WASM file
    const wasmPath = resolve(projectRoot, 'node_modules/@loading/taffy/lib/taffy_layout_bg.wasm')
    const wasmBytes = await readFile(wasmPath)
    
    // Read the generated JS file to extract the necessary parts
    const jsPath = resolve(projectRoot, 'node_modules/@loading/taffy/lib/taffy_layout.generated.js')
    const jsContent = await readFile(jsPath, 'utf8')
    
    // Create output directory
    const outputDir = resolve(projectRoot, 'src/taffy/prebuilt')
    await mkdir(outputDir, { recursive: true })
    
    // Convert WASM to base64
    const wasmBase64 = wasmBytes.toString('base64')
    
    // Create the pre-built module
    const prebuiltModule = `// Pre-built Taffy WASM module
// Generated by scripts/build-taffy.js - DO NOT EDIT

// WASM binary embedded as base64
const wasmBase64 = "${wasmBase64}"

// Convert base64 to Uint8Array
function base64ToUint8Array(base64) {
  const binaryString = atob(base64)
  const bytes = new Uint8Array(binaryString.length)
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i)
  }
  return bytes
}

// Extracted from @loading/taffy with modifications for pre-built usage
` + extractWasmRuntime(jsContent) + `

// Pre-instantiated singleton
let wasmInstance = null
let wasmPromise = null

async function ensureWasmLoaded() {
  if (wasmInstance) return wasmInstance
  
  if (wasmPromise) {
    await wasmPromise
    return wasmInstance
  }
  
  wasmPromise = (async () => {
    try {
      const wasmBytes = base64ToUint8Array(wasmBase64)
      const wasmModule = await WebAssembly.instantiate(wasmBytes, imports)
      
      // Initialize the WASM globals
      wasm = wasmModule.instance.exports
      cachedInt32Memory0 = new Int32Array(wasm.memory.buffer)
      cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer)
      
      wasmInstance = {
        instance: wasmModule.instance,
        exports: { Layout, Node, TaffyTree }
      }
      
      console.log('‚úÖ Taffy WASM loaded successfully (pre-built)')
      return wasmInstance
    } catch (error) {
      console.error('‚ùå Failed to load pre-built Taffy WASM:', error)
      throw error
    } finally {
      wasmPromise = null
    }
  })()
  
  await wasmPromise
  return wasmInstance
}

export async function instantiate() {
  const instance = await ensureWasmLoaded()
  return instance.exports
}

export async function instantiateWithInstance() {
  return await ensureWasmLoaded()
}

export function isInstantiated() {
  return wasmInstance != null
}
`

    // Write the pre-built module
    await writeFile(resolve(outputDir, 'index.js'), prebuiltModule)
    
    // Create TypeScript declarations
    const dtsContent = `// Pre-built Taffy WASM type declarations
export * from '@loading/taffy'
export function instantiate(): Promise<{ Layout: any, Node: any, TaffyTree: any }>
export function instantiateWithInstance(): Promise<{ instance: WebAssembly.Instance, exports: any }>
export function isInstantiated(): boolean
`
    await writeFile(resolve(outputDir, 'index.d.ts'), dtsContent)
    
    console.log('‚úÖ Pre-built Taffy WASM created successfully!')
    console.log(`   - WASM size: ${(wasmBytes.length / 1024).toFixed(1)}KB`)
    console.log(`   - Base64 size: ${(wasmBase64.length / 1024).toFixed(1)}KB`)
    console.log(`   - Output: src/taffy/prebuilt/`)
    
  } catch (error) {
    console.error('‚ùå Failed to build pre-built Taffy:', error)
    process.exit(1)
  }
}

function extractWasmRuntime(jsContent) {
  // Extract the essential WASM runtime code, excluding the loader
  const lines = jsContent.split('\n')
  const startMarkers = [
    'let wasm;',
    'const heap = new Array(128)',
    'let heap_next = heap.length;'
  ]
  const endMarkers = [
    'class WasmBuildLoader',
    'const loader = new WasmBuildLoader'
  ]
  
  let startIndex = -1
  let endIndex = lines.length
  
  // Find start
  for (let i = 0; i < lines.length; i++) {
    if (startMarkers.some(marker => lines[i].includes(marker))) {
      startIndex = i
      break
    }
  }
  
  // Find end (before loader)
  for (let i = startIndex + 1; i < lines.length; i++) {
    if (endMarkers.some(marker => lines[i].includes(marker))) {
      endIndex = i
      break
    }
  }
  
  if (startIndex === -1) {
    throw new Error('Could not find WASM runtime start marker')
  }
  
  const runtimeCode = lines.slice(startIndex, endIndex).join('\n')
  
  // Check if imports object already exists in the runtime
  const hasImports = runtimeCode.includes('const imports = {')
  
  if (hasImports) {
    // If imports already exists, just return the runtime code
    return runtimeCode
  }
  
  // Add imports object only if it doesn't exist
  const importsCode = `
// WASM imports
const imports = {
  __wbindgen_placeholder__: {
    __wbindgen_object_drop_ref: function(arg0) {
      takeObject(arg0);
    },
    __wbindgen_string_new: function(arg0, arg1) {
      const ret = getStringFromWasm0(arg0, arg1);
      return addHeapObject(ret);
    },
    __wbindgen_object_clone_ref: function(arg0) {
      const ret = getObject(arg0);
      return addHeapObject(ret);
    },
    __wbindgen_is_undefined: function(arg0) {
      const ret = getObject(arg0) === undefined;
      return ret;
    },
    __wbindgen_in: function(arg0, arg1) {
      const ret = getObject(arg0) in getObject(arg1);
      return ret;
    },
    __wbindgen_is_bigint: function(arg0) {
      const ret = typeof(getObject(arg0)) === 'bigint';
      return ret;
    },
    __wbindgen_bigint_from_u64: function(arg0) {
      const ret = BigInt.asUintN(64, arg0);
      return addHeapObject(ret);
    },
    __wbindgen_jsval_eq: function(arg0, arg1) {
      const ret = getObject(arg0) === getObject(arg1);
      return ret;
    },
    __wbindgen_error_new: function(arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    },
    __wbindgen_is_object: function(arg0) {
      const val = getObject(arg0);
      const ret = typeof(val) === 'object' && val !== null;
      return ret;
    },
    __wbindgen_is_string: function(arg0) {
      const ret = typeof(getObject(arg0)) === 'string';
      return ret;
    },
    __wbindgen_string_get: function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof(obj) === 'string' ? obj : undefined;
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    },
    __wbindgen_number_new: function(arg0) {
      const ret = arg0;
      return addHeapObject(ret);
    },
    __wbindgen_number_get: function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof(obj) === 'number' ? obj : undefined;
      getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
      getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
    },
    __wbindgen_boolean_get: function(arg0) {
      const v = getObject(arg0);
      const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;
      return ret;
    },
    __wbindgen_is_null: function(arg0) {
      const ret = getObject(arg0) === null;
      return ret;
    },
    __wbindgen_is_falsy: function(arg0) {
      const ret = !getObject(arg0);
      return ret;
    },
    __wbindgen_as_number: function(arg0) {
      const ret = +getObject(arg0);
      return ret;
    },
    __wbg_instanceof_Window_c4b70662a0d2c5ec: function() { return false; },
    __wbg_document_8554450897a855b9: function() { return addHeapObject({}); },
    __wbg_location_2951b5ee34f19221: function() { return addHeapObject({}); },
    __wbg_hostname_eb2f00ead8103e7c: function() { return addHeapObject("localhost"); },
    __wbindgen_throw: function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    },
  },
};
`
  
  return importsCode + '\n' + runtimeCode
}

// Run the build
buildTaffyPrebuilt() 